(** Summary of the formalization (kernel)

Tip: The Coq command [About ident] prints where the ident was defined
 *)

Require Import UniMath.Foundations.PartD.
Require Import UniMath.CategoryTheory.Core.Categories.
Require Import UniMath.CategoryTheory.Core.Isos.
Require Import UniMath.CategoryTheory.Core.NaturalTransformations.
Require Import UniMath.CategoryTheory.Core.Functors.
Require Import UniMath.CategoryTheory.whiskering.
Require Import UniMath.CategoryTheory.PrecategoryBinProduct.

Require Import UniMath.CategoryTheory.Chains.Chains.
Require Import UniMath.CategoryTheory.Chains.Adamek.
Require Import UniMath.CategoryTheory.Chains.OmegaCocontFunctors.
Require Import UniMath.CategoryTheory.limits.graphs.colimits.
Require Import UniMath.CategoryTheory.limits.bincoproducts.
Require Import UniMath.CategoryTheory.limits.initial.
Require Import UniMath.CategoryTheory.limits.graphs.eqdiag.
Require Import UniMath.CategoryTheory.FunctorAlgebras.
Require Import UniMath.CategoryTheory.FunctorCategory.
Require Import UniMath.CategoryTheory.coslicecat.

Require Import UniMath.CategoryTheory.SkewMonoidal.SkewMonoidalCategories.
Require Import UniMath.CategoryTheory.SkewMonoidal.CategoriesOfMonoids.
Require Import UniMath.CategoryTheory.limits.graphs.coequalizers.

Require Import StructuralStrengths.
Require Import IModules.
Require Import Complements.
Require Import InitialAlgebraicMonoid.

Local Open Scope cat.

(** Notation for product of functors *)
Delimit Scope functor_scope with F.
Infix "√ó√ó" := pair_functor (at level 31).

(* Notation for product category *)
Infix "√óC" := precategory_binproduct (at level 38).
(** Notation for constructing objects and morphisms of a product category *)
Notation "( c , d )" := (make_catbinprod c d).
Notation "( f #, g )" := (catbinprodmor f g).



(**
The command:

Check (x ‚â° y) 

succeeds if and only if [x] is convertible to [y]

*)
Notation  "x ‚â° y :> A "  := (@paths_refl A x = @paths_refl A y) (at level 70, y at next level, no associativity).
Notation  "x ‚â° y"  := (paths_refl x = paths_refl y) (at level 70, no associativity).

Fail Check (true ‚â° false).
Check (true ‚â° true).



Section Summary.


(** We suppose given a skew monoidal category V
 *)
Context (V : skewmonoidal_category).

(** Some notations for the monoidal structure *)
Notation tensor := (skewmonoidal_tensor (data_from_skewmonoidal V)).
Notation I := (skewmonoidal_I (data_from_skewmonoidal V)).
Notation Œ±' := (skewmonoidal_assoc (data_from_skewmonoidal V)).
Notation Œª' := (skewmonoidal_unitl (data_from_skewmonoidal V)).
Notation œÅ' := (skewmonoidal_unitr (data_from_skewmonoidal V)).

(** We denote ‚äó the tensor product, and #‚äó the action on morphisms *)
Notation "X ‚äó Y" := (tensor (X , Y)).
Notation "f #‚äó g" :=
   (functor_on_morphisms (functor_data_from_functor _ _ tensor) (f #, g))
                         (at level 31).


(** * I-modules and pointed I-modules
covered by IModules.v 
 *)



(**
A I-module on V consists of an object F of V together
with a map F ‚äó I ‚Üí F, subject to some laws given later.
There is an implicit coercion between I-modules and objects of V
 *)
Check ((IModule_data V) ‚â° (‚àë (F : V), F ‚äó I --> F : UU)).

(** Some notations for the action *)
Check (‚àè  F : IModule_data V, im_action V F ‚â° (pr2 F : F ‚äó I --> F)).
Notation œÉ := (im_action V).

(** A I-module consists of the data previously defined subject to
  two laws *)
Check (IModule V ‚â°
         ‚àë (F : IModule_data V) ,
         (** First law *)
         (œÅ' F ¬∑ œÉ F  = identity _)
           √ó
           (** Second law *)
           (Œ±' F I I ¬∑ (identity _) #‚äó Œª' I ¬∑ œÉ F  =
            œÉ F #‚äó identity I ¬∑ œÉ F)
      ).


(** A morphism between I-modules X and Y is a morphism between
underlying objects of V preserving the action
 *)
Check  (‚àè (X Y : IModule V),
        IModule_Mor V X Y ‚â°
          ‚àë (f :  V ‚ü¶X, Y‚üß) , 
            (** the morphism is compatible with œÉ *)
             œÉ X ¬∑ f = (f #‚äó identity _) ¬∑ œÉ Y).

          (* (** the unit is preserved *) *)
          (* (œµ X ¬∑ f = œµ Y) *)

(** I-modules form a category  *)
Check (precategory_IModule V ‚â°
          (make_precategory_ob_mor (IModule V) (IModule_Mor V)
             ,, _) ,, _ ,, _).


(** The unit can be given the structure of a pointed I-module *)
Notation IM := (IModule_I V).
(** Checking the underlying V object. *)
Check ((IM : V) ‚â° I).

(** The category of pointed I-modules is the coslice category of the category
of I-modules under I *)
Check (precategory_PtIModule V ‚â°
                             coslice_precat (precategory_IModule V ) IM
                             (has_homsets_IModule V IM)).

Notation PtIM_Cat := (category_PtIModule V).

Check (PtIModule V ‚â° ob PtIM_Cat).

(* Notation for the point *)
Notation œµ := (im_unit V).

(** IM is canonically a pointed I-module *)
Notation IP := (PtIModule_I V).
Check ((IP : IModule V) ‚â° IM).
Check (œµ IP ‚â° identity (C := precategory_IModule V) IM).

(** The forgetful functor from pointed I-modules to V *)
Check (forget_PtIModules V : functor PtIM_Cat V).

(** We use the notation ùí∞ in the following when we want to make explicit the
coercion between pointed I-modules and objects of V. *)
Notation ùí∞ := (forget_PtIModules V).
Check (‚àè (X : PtIModule V), ùí∞ X ‚â° (X : V)).



(** There is a tensor product on pointed I-modules, defined as a coequalizer,
here called [PtIModule_tensor].
This requires that V has coequalizers (in fact, reflexive coequalizers are enough), and
the tensoring on the right with I preserves them.
 *)
Context (coeqsV : coequalizers.Coequalizers V).
Context  (tensorl_coeqs : preserves_colimits_of_shape
                            ((functor_fix_snd_arg _ _ _ tensor I)) coequalizers.Coequalizer_graph ).

Check (PtIModule_tensor V coeqsV tensorl_coeqs
       : PtIModule V ‚Üí PtIModule V ‚Üí PtIModule V).
Infix "‚ä†M" := (PtIModule_tensor V coeqsV tensorl_coeqs) (at level 31).

(** The underlying object of V of the tensor is the coequalizer of two morphisms
 from (X ‚äó I) ‚äó Y to X ‚äó Y
 *)
Check  (‚àè (X Y : PtIModule V),
        ùí∞ (X ‚ä†M Y) ‚â°
          CoequalizerObject
               V (coeqsV ((X ‚äó I) ‚äó Y) (X ‚äó Y)
                         (** Here is the first one *)
                         (Œ±' X I Y ¬∑ identity X #‚äó Œª' Y)
                         (** Here is the second one *)
                         (œÉ X #‚äó identity Y)
            )).

(** Notation for the coequalizer arrow *)
Notation Œ∫ := (IModule_tensor'_proj V coeqsV tensorl_coeqs).
Check (fun (M N : PtIModule V) => Œ∫ M N : M ‚äó N --> M ‚ä†M N).


(** The tensor product can be lifted to the category of I-modules, there
 called [IModule_tensor] *)
(*
Check (IModule_tensor V : IModule V -> IModule V -> IModule V ).
Infix "‚äóM" := (IModule_tensor V) (at level 31).

Lemma IModule_tensor_lifts_tensor (A B : IModule V) :
  ùí∞ (A ‚äóM B) = (ùí∞ A) ‚äó (ùí∞ B).
Proof.
  reflexivity.
Qed.
*)



(** * Structural strengths 
covered by StructuralStrengths.v

************* *)

(** We suppose given an endofunctor H on V *)
Context  (H : V ‚ü∂ V).

(** A structural strength consists of a natural transformation between
the two relevant parallel functors from V √ó M (denoted by V ‚ä† M below)
to V, subject to two laws.

There is an implicit coercion between strengths and natural
transformations.  *)
Check (strength coeqsV tensorl_coeqs H ‚â°
         ‚àë (st : nat_trans (C := V √óC PtIM_Cat) (C' := V)
                   ((H √ó√ó ùí∞) ‚àô tensor)
                   ((functor_identity _ √ó√ó ùí∞) ‚àô tensor ‚àô H)
           ),
         (** first law: triangle *)
         (‚àè (a : V), œÅ' (H a) ¬∑ st (a, (IP : PtIM_Cat))  = # H (œÅ' a))
         (** second law: pentagon *)
           √ó
           (‚àè (a : V),
            ‚àè (x y : PtIModule V) ,
            Œ±' (H a) x y ¬∑ identity (H a) #‚äó Œ∫ x y ¬∑ st (a , (x ‚ä†M y : PtIM_Cat))
            =
            (st (a, (x : PtIM_Cat)) #‚äó identity y)
              ¬∑ st ((a ‚äó x), (y : PtIM_Cat))
              ¬∑ # H (Œ±' a x y ¬∑ identity a #‚äó Œ∫ x y))).

(** * Skew H-monoids

.. for H a strong endofonctor on V

covered by StructuralStrengths.v

************* *)


(** Notations for the unit and multiplication of a (skew) monoid (see
    SkewMonoids.v for the precise definition) *)
Local Definition Œ∑ (m : skewMonoid V) : V ‚ü¶I , m‚üß := sm_unit V m.
Local Definition Œº (m : skewMonoid V) : V ‚ü¶m ‚äó m, m‚üß := sm_mult V m.

(** We suppose given a strength for the endofunctor H *)
Context (st : strength coeqsV tensorl_coeqs H).

(**
A H-monoid consists of a skew monoid with an H algebra structure,
subject to some laws.
There is an implicit coercion between H-monoids and skew monoids.
 *)
Check (@algMonoid_data V H ‚â° ‚àë X : skewMonoid V, H X --> X).

(** Notation for the algebra structure *)
Check (‚àè (X : algMonoid_data), am_alg X ‚â° (pr2 X : H X --> X)).

Local Notation Œ≥ := am_alg.

(** A H-monoid consists of the data previously detailed subject to an equation *)
Check (algMonoid st ‚â°
         ‚àë (X : algMonoid_data),
         st X (PtIModule_from_monoid _ X)
           ¬∑ # H (Œº X) ¬∑ Œ≥ X
         = Œ≥ X #‚äó identity X ¬∑ (Œº X)).

(** A H-monoid morphism between H-monoids X and Y consists of a morphism that is
both a morphism of skew monoids and of algebras *)
Check  (‚àè (X Y : algMonoid st),
        algMonoid_Mor X Y ‚â°
          ‚àë (f : skewMonoid_Mor _ X Y) , Œ≥ X ¬∑ f = # H f ¬∑ (Œ≥ Y)).


(** H-monoids form a category (see StructuralStrengths.precategory_algMonoid
   for the details)
 *)
Check ( precategory_algMonoid st ‚â°
          (make_precategory_ob_mor (algMonoid st) (algMonoid_Mor (F := H) )
             ,, _) ,, _ ,, _).

End Summary.

(** * Axiomatized theorem from Fiore-Saville

Covered by Complements.v
Axiomatization of Theorem 4.7 of "List object with
algebraic structure" (Fiore-Saville, extended version).

This is the only admitted result of this formalization.

 *)

Check (@Thm47 :
         ‚àè {D C B A : category}
           (OC : Initial C)(chC : Colims_of_shape nat_graph C)
           (chA : Colims_of_shape nat_graph A)
           {J : C ‚ü∂ A}(OJ : isInitial _ (J (InitialObject OC)))
           (omegaJ : is_omega_cocont J)
           {F : D √óC C ‚ü∂ C}
           (omegaF : ‚àè d , is_omega_cocont (functor_fix_fst_arg _ _ _ F d))
           {G : B √óC A ‚ü∂ A}
           (omegaG : ‚àè b , is_omega_cocont (functor_fix_fst_arg _ _ _ G b))
           {K : D ‚ü∂ B} (h : F ‚àô J ‚üπ (K √ó√ó J) ‚àô G)
           {a : A}{d : D}(Œ± : A ‚ü¶ G (K d , a) , a ‚üß)
           (** Initial algebra of F(_, d) using Adamek's lemma *)
           (ŒºFd :=
              (InitialObject
                 (colimAlgInitial
                    OC (omegaF d)
                    (chC (initChain OC (functor_fix_fst_arg D C C F d)))))),
         ‚àÉ! (Œ≤ : A ‚ü¶ J (alg_carrier _ ŒºFd) , a ‚üß),
         h (d , alg_carrier _ ŒºFd) ¬∑ # G ( identity _ #, Œ≤ ) ¬∑ Œ±  =
         # J (alg_map _ ŒºFd) ¬∑ Œ≤).



(** * Main result,
 stated in a void context: the category of H-monoids has an
 initial object under the following assumptions

covered by InitialAlgebraicMonoid.v
 *)
Check (algMonoid_Initial :
           (** V is a skew monoidal category *)
        ‚àè (V : skewmonoidal_category),
         (** V has colimits of chains *)
         Colims_of_shape nat_graph V ->
         (** V has an initial object *)
         Initial V ->
         (** V has binary coproducts *)
         BinCoproducts V ->
         (** V has coequalizers *)
         ‚àè (coeqsV : Coequalizers V)
         (** the tensor is left cocontinuous *)
         (ltensor_CC : (‚àè X : V,
                 is_cocont
                   (functor_fix_snd_arg V V V (skewmonoidal_tensor V) X)))
         (** H is an endofunctor on V with a strength *),
      ‚àè (H : V ‚ü∂ V) (st : strength coeqsV _ H),
         (** H is omega cocontinuous *)
         is_omega_cocont H ‚Üí
         Initial (precategory_algMonoid st)
         ).

(** Notation for binary coproducts of functors *)
Infix "++" := (BinCoproduct_of_functors _ _ _) .

(** The underlying object of V is the initial algebra of the endofunctor
    X ‚Ü¶ I + H(X) *)
Definition underlying_object :
         ‚àè (V : skewmonoidal_category)
         œâ O cp coeqsV lcc 
         H st
         Hœâcc,
       ((InitialObject (algMonoid_Initial V œâ O cp coeqsV lcc H st Hœâcc)
         : algMonoid st)
          (** The coercion yields the underlying object of V *)
        : V) =
       (** [alg_carrier F a] takes an F-algebra a and returns the underlying
           object *)
         alg_carrier
           (** here, F = I + H *)
           (constant_functor _ _ (skewmonoidal_I V) ++ H)
           (** and we consider the initial algebra *)
           (InitialObject (colimAlgInitial _ _ _))
  := 
    (* The proof *)
    (fun V œâ O cp coeqsV lcc H st Hœâcc =>
       A_is_InitialAlg_sumFI V œâ O cp H Hœâcc).

